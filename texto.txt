Choosing the right mapping is critical for both performance and domain clarity
To use Hibernate in a Java project, you typically need to include the hibernate-core dependency
Database Driver
JPA API (if you're using Hibernate as a JPA provider)
Connection Pooling is recommended because hibernate doesn’t automatically pull in all optional modules, so if you need features like envers, validator, or search, you’ll need to add those dependencies
Use HQL for standard CRUD, and object-oriented operations.
Use Native SQL when you must a specific database function, when dealing with complex, non-entity-based joins, or for bulk operations where object loading is inefficient.
We use the JPA `EntityManager` for most of the application logic and we can use native SQL using `entityManager.createNativeQuery()`.

The L1 cache is built into and tied to the lifecycle of a Session object. It improves performance by ensuring that the same entity is retrieved from memory rather than re-querying the database within a single session. 
The L2 cache is optional and exists at the SessionFactory level, meaning it is shared across all sessions and transactions within an application. It is designed to cache frequently used data that persists beyond a single session's lifespan. 
Hibernate also provides an optional query cache to store the results of frequently executed queries. 
Hibernate packed with features like caching, lazy loading, and HQL, which makes it a solid pick for complex apps. 
But if you’re just looking to write tight SQL and don’t mind skipping the whole ORM automation, then lighter tools like MyBatis or Jooq might be more your vibe.
 